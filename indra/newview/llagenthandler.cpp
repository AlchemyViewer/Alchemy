/**
 * @file llagenthandler.cpp
 * @brief Command handler involving agent requests
 *
 * $LicenseInfo:firstyear=2005&license=viewerlgpl$
 * Second Life Viewer Source Code
 * Copyright (C) 2010, Linden Research, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation;
 * version 2.1 of the License only.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Linden Research, Inc., 945 Battery Street, San Francisco, CA  94111  USA
 * $/LicenseInfo$
 */

#include "llviewerprecompiledheaders.h"

#include "llavataractions.h"
#include "llcommandhandler.h"
#include "llfloaterreg.h"
#include "llfloaterreporter.h"
#include "llmutelist.h"
#include "llnotificationsutil.h"
//#include "llpanelblockedlist.h"
#include "llfloaterblocked.h"

class LLAgentHandler : public LLCommandHandler
{
public:
    // requires trusted browser to trigger
    LLAgentHandler() : LLCommandHandler("agent", UNTRUSTED_THROTTLE) { }

    virtual bool canHandleUntrusted(
        const LLSD& params,
        const LLSD& query_map,
        LLMediaCtrl* web,
        const std::string& nav_type)
    {
        if (params.size() < 2)
        {
            return true; // don't block, will fail later
        }

        if (nav_type == NAV_TYPE_CLICKED
            || nav_type == NAV_TYPE_EXTERNAL)
        {
            return true;
        }

        const std::string verb = params[1].asString();
        if (verb == "about" || verb == "inspect" || verb == "reportAbuse")
        {
            return true;
        }
        return false;
    }

    bool handle(const LLSD& params, const LLSD& query_map, const std::string& grid,
        LLMediaCtrl* web)
    {
        if (params.size() < 2) return false;
        LLUUID avatar_id;
        if (!avatar_id.set(params[0].asStringRef(), FALSE))
        {
            return false;
        }

        const std::string verb = params[1].asString();
        if (verb == "about")
        {
            LLAvatarActions::showProfile(avatar_id);
            return true;
        }

        if (verb == "inspect")
        {
            LLFloaterReg::showInstance("inspect_avatar", LLSD().with("avatar_id", avatar_id));
            return true;
        }

        if (verb == "im")
        {
            LLAvatarActions::startIM(avatar_id);
            return true;
        }

        if (verb == "pay")
        {
            if (!LLUI::getInstance()->mSettingGroups["config"]->getBOOL("EnableAvatarPay"))
            {
                LLNotificationsUtil::add("NoAvatarPay", LLSD(), LLSD(), std::string("SwitchToStandardSkinAndQuit"));
                return true;
            }

            LLAvatarActions::pay(avatar_id);
            return true;
        }

        if (verb == "offerteleport")
        {
            LLAvatarActions::offerTeleport(avatar_id);
            return true;
        }

        if (verb == "requestfriend")
        {
            LLAvatarActions::requestFriendshipDialog(avatar_id);
            return true;
        }

        if (verb == "removefriend")
        {
            LLAvatarActions::removeFriendDialog(avatar_id);
            return true;
        }

        if (verb == "mute")
        {
            if (! LLAvatarActions::isBlocked(avatar_id))
            {
                LLAvatarActions::toggleBlock(avatar_id);
            }
            return true;
        }

        if (verb == "unmute")
        {
            if (LLAvatarActions::isBlocked(avatar_id))
            {
                LLAvatarActions::toggleBlock(avatar_id);
            }
            return true;
        }

        if (verb == "block")
        {
            if (params.size() > 2)
            {
                const std::string object_name = LLURI::unescape(params[2].asString());
                LLMute mute(avatar_id, object_name, LLMute::OBJECT);
                LLMuteList::getInstance()->add(mute);
                LLFloaterBlocked::showMuteAndSelect(mute.mID);
                //LLPanelBlockedList::showPanelAndSelect(mute.mID);
            }
            return true;
        }

        if (verb == "unblock")
        {
            if (params.size() > 2)
            {
                const std::string object_name = params[2].asString();
                LLMute mute(avatar_id, object_name, LLMute::OBJECT);
                LLMuteList::getInstance()->remove(mute);
            }
            return true;
        }

        // reportAbuse is here due to convoluted avatar handling
        // in LLScrollListCtrl and LLTextBase
        if (verb == "reportAbuse" && web == NULL)
        {
            LLAvatarName av_name;
            if (LLAvatarNameCache::get(avatar_id, &av_name))
            {
                LLFloaterReporter::showFromAvatar(avatar_id, av_name.getCompleteName());
            }
            else
            {
                LLFloaterReporter::showFromAvatar(avatar_id, "not avaliable");
            }
            return true;
        }
        return false;
    }
};
LLAgentHandler gAgentHandler;
